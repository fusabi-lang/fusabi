//! FSRS Demo Host Library
//!
//! This library provides the core functionality for executing Mini-F# scripts
//! through the complete FSRS pipeline: Lexer -> Parser -> Compiler -> VM.

use fsrs_frontend::{Compiler, Lexer, Parser};
use fsrs_vm::{Value, Vm};
use std::error::Error;
use std::fmt;
use std::fs;

/// Unified error type for the FSRS pipeline
#[derive(Debug)]
pub enum FsrsError {
    /// IO error reading source file
    Io(std::io::Error),
    /// Lexer error during tokenization
    Lex(fsrs_frontend::LexError),
    /// Parser error during parsing
    Parse(fsrs_frontend::ParseError),
    /// Compiler error during bytecode generation
    Compile(fsrs_frontend::CompileError),
    /// VM runtime error during execution
    Runtime(fsrs_vm::VmError),
}

impl fmt::Display for FsrsError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FsrsError::Io(e) => write!(f, "IO Error: {}", e),
            FsrsError::Lex(e) => write!(f, "Lexer Error: {}", e),
            FsrsError::Parse(e) => write!(f, "Parser Error: {}", e),
            FsrsError::Compile(e) => write!(f, "Compiler Error: {}", e),
            FsrsError::Runtime(e) => write!(f, "Runtime Error: {}", e),
        }
    }
}

impl Error for FsrsError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        match self {
            FsrsError::Io(e) => Some(e),
            FsrsError::Lex(e) => Some(e),
            FsrsError::Parse(e) => Some(e),
            FsrsError::Compile(e) => Some(e),
            FsrsError::Runtime(e) => Some(e),
        }
    }
}

impl From<std::io::Error> for FsrsError {
    fn from(err: std::io::Error) -> Self {
        FsrsError::Io(err)
    }
}

impl From<fsrs_frontend::LexError> for FsrsError {
    fn from(err: fsrs_frontend::LexError) -> Self {
        FsrsError::Lex(err)
    }
}

impl From<fsrs_frontend::ParseError> for FsrsError {
    fn from(err: fsrs_frontend::ParseError) -> Self {
        FsrsError::Parse(err)
    }
}

impl From<fsrs_frontend::CompileError> for FsrsError {
    fn from(err: fsrs_frontend::CompileError) -> Self {
        FsrsError::Compile(err)
    }
}

impl From<fsrs_vm::VmError> for FsrsError {
    fn from(err: fsrs_vm::VmError) -> Self {
        FsrsError::Runtime(err)
    }
}

/// Execute Mini-F# source code from a string
///
/// # Pipeline
/// 1. Tokenize the source using the Lexer
/// 2. Parse tokens into an AST using the Parser
/// 3. Compile AST to bytecode using the Compiler
/// 4. Execute bytecode in the VM
///
/// # Example
/// ```
/// use fsrs_demo::run_source;
/// use fsrs_vm::Value;
///
/// let result = run_source("let x = 42 in x + 1").unwrap();
/// assert_eq!(result, Value::Int(43));
/// ```
pub fn run_source(source: &str) -> Result<Value, FsrsError> {
    // Stage 1: Lexical Analysis
    let mut lexer = Lexer::new(source);
    let tokens = lexer.tokenize()?;

    // Stage 2: Parsing
    let mut parser = Parser::new(tokens);
    let ast = parser.parse()?;

    // Stage 3: Compilation
    let chunk = Compiler::compile(&ast)?;

    // Stage 4: Execution
    let mut vm = Vm::new();
    let result = vm.execute(chunk)?;

    Ok(result)
}

/// Execute a Mini-F# script from a file
///
/// # Example
/// ```no_run
/// use fsrs_demo::run_file;
///
/// let result = run_file("examples/hello.fsrs").unwrap();
/// println!("Result: {}", result);
/// ```
pub fn run_file(path: &str) -> Result<Value, FsrsError> {
    let source = fs::read_to_string(path)?;
    run_source(&source)
}

/// Execute source with optional disassembly output
///
/// Useful for debugging - prints the generated bytecode before execution
pub fn run_source_with_disasm(source: &str, name: &str) -> Result<Value, FsrsError> {
    // Stage 1: Lexical Analysis
    let mut lexer = Lexer::new(source);
    let tokens = lexer.tokenize()?;

    // Stage 2: Parsing
    let mut parser = Parser::new(tokens);
    let ast = parser.parse()?;

    // Stage 3: Compilation
    let chunk = Compiler::compile(&ast)?;

    // Disassemble the chunk
    println!("\n=== Disassembly of '{}' ===", name);
    chunk.disassemble();
    println!("=== End Disassembly ===\n");

    // Stage 4: Execution
    let mut vm = Vm::new();
    let result = vm.execute(chunk)?;

    Ok(result)
}

/// Execute file with optional disassembly output
pub fn run_file_with_disasm(path: &str) -> Result<Value, FsrsError> {
    let source = fs::read_to_string(path)?;
    run_source_with_disasm(&source, path)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_run_source_simple() {
        let result = run_source("42").unwrap();
        assert_eq!(result, Value::Int(42));
    }

    #[test]
    fn test_run_source_arithmetic() {
        let result = run_source("10 + 5").unwrap();
        assert_eq!(result, Value::Int(15));
    }

    #[test]
    fn test_run_source_let_binding() {
        let result = run_source("let x = 20 in x * 2").unwrap();
        assert_eq!(result, Value::Int(40));
    }

    #[test]
    fn test_run_source_error_undefined() {
        let result = run_source("undefined_var");
        assert!(result.is_err());
    }

    #[test]
    fn test_run_source_error_lex() {
        let result = run_source("42 @ 10");
        assert!(result.is_err());
    }
}
